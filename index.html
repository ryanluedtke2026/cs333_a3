<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 Normalized Line</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
    }
  </style>
</head>

<body>

<div id="chart"></div>

<script>

// ----------------------------------------------------------------
// LOAD CSV (name, date, value)
// ----------------------------------------------------------------
d3.csv("clean_bls_long_format.csv", d => ({
  name: d.name.trim(),
  date: new Date(d.date),
  value: +d.value
})).then(raw => {

  let filtered = raw.filter(d =>
    d.name.includes("Total nonfarm Total US") &&
    (
      d.name.includes("Hires") ||
      d.name.includes("Job openings") ||
      d.name.includes("Total separations")
    )
  );
  console.log("RAW DATA:", raw);


  // CLEAN bad values + invalid dates
  filtered = filtered.filter(d =>
    d.value > 0 &&              
    d.date instanceof Date &&
    !isNaN(d.date.getTime())
  );

  console.log("FILTERED (name includes Total nonfarm Total US):", filtered);
  


  // Sort overall
  filtered.sort((a, b) => a.date - b.date);

  // Map to chart structure
  const stocks = filtered.map(d => ({
    Symbol:
      d.name.includes("Hires") ? "Hires" :
      d.name.includes("Job openings") ? "Job openings" :
      d.name.includes("Total separations") ? "Total separations" :
      d.name,
    Date: d.date,
    Close: d.value
  }));
  console.log("STOCKS (input to chart):", stocks);

  // ----------------------------------------------------------------
  // YOUR ORIGINAL CHART CODE — Unmodified Below This Point
  // ----------------------------------------------------------------

  const width = 928;
  const height = 600;
  const marginTop = 20;
  const marginRight = 40;
  const marginBottom = 30;
  const marginLeft = 40;

  const x = d3.scaleUtc()
    .domain(d3.extent(stocks, d => d.Date))
    .range([marginLeft, width - marginRight])
    .clamp(true);

  const series = d3.groups(stocks, d => d.Symbol).map(([key, values]) => {
    const v0 = values[0].Close;
    return {
      key,
      values: values.map(({Date, Close}) => ({Date, value: Close / v0}))
    };
  });

  const k = d3.max(series, ({values}) =>
    d3.max(values, d => d.value) / d3.min(values, d => d.value)
  );

  const y = d3.scaleLog()
    .domain([1 / k, k])
    .rangeRound([height - marginBottom, marginTop]);

  const z = d3.scaleOrdinal(d3.schemeCategory10)
    .domain(series.map(d => d.key));

  const bisect = d3.bisector(d => d.Date).left;

  const svg = d3.select("#chart")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height]);

  svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0))
    .call(g => g.select(".domain").remove());

  svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y).ticks(null, x => +x.toFixed(6) + "×"))
    .call(g => g.selectAll(".tick line").clone()
      .attr("stroke-opacity", d => d === 1 ? null : 0.2)
      .attr("x2", width - marginLeft - marginRight))
    .call(g => g.select(".domain").remove());

  const rule = svg.append("line")
    .attr("y1", height)
    .attr("y2", 0)
    .attr("stroke", "black");

  const line = d3.line()
    .x(d => x(d.Date))
    .y(d => y(d.value));

  const serie = svg.append("g")
    .selectAll("g")
    .data(series)
    .join("g");

  serie.append("path")
    .attr("fill", "none")
    .attr("stroke-width", 1.5)
    .attr("stroke-linejoin", "round")
    .attr("stroke-linecap", "round")
    .attr("stroke", d => z(d.key))
    .attr("d", d => line(d.values));

  serie.append("text")
    .datum(d => ({
      key: d.key,
      value: d.values[d.values.length - 1].value
    }))
    .attr("x", x.range()[1] + 3)
    .attr("y", d => y(d.value))
    .attr("dy", "0.35em")
    .attr("fill", d => z(d.key))
    .attr("stroke", "white")
    .attr("stroke-width", 3)
    .text(d => d.key);

  function update(date) {
    date = d3.utcDay.round(date);

    rule.attr("transform", `translate(${x(date)},0)`);

    serie.attr("transform", ({values}) => {
      const i = bisect(values, date, 0, values.length - 1);
      const shift = y(1) - y(values[i].value / values[0].value);
      return `translate(0,${shift})`;
    });
  }

  d3.transition()
    .ease(d3.easeCubicOut)
    .duration(1500)
    .tween("date", () => {
      const interp = d3.interpolateDate(x.domain()[1], x.domain()[0]);
      return t => update(interp(t));
    });

  svg.on("mousemove touchmove", function(event) {
    const [px] = d3.pointer(event, this);
    update(x.invert(px));
  });

});  // END CSV LOAD

</script>

</body>
</html>
