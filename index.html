<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 Labor Market Metrics</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
    }
    #chart-left, #chart-right {
      display: inline-block;
      vertical-align: top;
      margin: 0 10px;
    }

    button {
      padding: 8px 16px;
      margin: 0 5px;
      font-size: 14px;
      cursor: pointer;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button.active {
      background-color: black;
      color: white;
    }
    select {
      padding: 8px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
</head>

<body>

<h1 style="text-align: center; margin: 20px 0;">Labor Market Metrics</h1>

<div style="text-align: center; margin-bottom: 20px;">
  <label for="industry-filter">Industry: </label>
  <select id="industry-filter"></select>
  
  <label for="region-filter" style="margin-left: 20px;">Region: </label>
  <select id="region-filter"></select>
</div>

<div style="display: flex; justify-content: center;">
  <div id="chart-left"></div>
  <div id="chart-right-container" style="position: relative;">
    <div style="text-align: center; margin-bottom: 10px;">
      <button id="button_rates" onclick="updateDataset('rates')">Rates</button>
      <button id="button_actual" onclick="updateDataset('actual')">Actual</button>
    </div>
    <div id="chart-right"></div>
  </div>
</div>

<script>

// Global variables 
const width = 700;
const height = 460;
const marginTop = 20;
const marginRight = 40;
const marginBottom = 30;
const marginLeft = 40;

let rawData, filteredData;
let ratesData = [], levelsData = [];
let currentData = 'rates';
let svgLeft, svgRight, xLeft, yLeft, zLeft, seriesLeft;
let ruleLeft, ruleRight;
let bisect; 

// load CSV
d3.csv("clean_bls_long_format_2.csv", d => ({
  name: d.name.trim(),
  date: new Date(d.date),
  value: +d.value
})).then(raw => {

  //filter data so that date is always valid
  rawData = raw.filter(d => 
    d.value > 0 &&              
    d.date instanceof Date &&
    !isNaN(d.date.getTime())
  );

  //industry and region dropdown categories
  const industryCat = ["Total nonfarm", 
    "Total private",
    "Trade, transportation, and utilities",
    "Construction", 
    "Financial activities", 
    "Information",
    "Leisure and hospitality",
    "Manufacturing",
    "Mining and logging",
    "Private education and health services",
    "Professional and business services",
    "Other services",
    "Government",
    "State and local",
    "Federal"
  ];

  const regionCat = ["US", "Midwest", "Northeast", "South", "West"];

  // Populate industry and region dropdown
  populateSelect("industry-filter", industryCat);
  populateSelect("region-filter", regionCat);

  // Initial selection
  document.getElementById("industry-filter").value = "Total nonfarm";
  document.getElementById("region-filter").value = "US";

  // Event listeners -- for interaction on the buttons
  document.getElementById("industry-filter").addEventListener("change", () => {
    if (document.getElementById("industry-filter").value !== "all") 
      document.getElementById("region-filter").value = "US";
    filterData();
  });

  document.getElementById("region-filter").addEventListener("change", () => {
    const region = document.getElementById("region-filter").value;
    if (region !== "all" && region !== "US") 
      document.getElementById("industry-filter").value = "Total nonfarm";
    filterData();
  });

  // Initial filter and chart
  filterData();
  document.getElementById('button_rates').classList.add('active');
});

// Get industry and get region functions
function getIndustry(name){
  const match = name.match(/^(.+?) Total US/);
  return match ? match[1].trim() : name;
}

function getRegion(name){
  if (name.includes("Total US")) return "US";
  if (name.includes("Midwest region")) return "Midwest";
  if (name.includes("Northeast region")) return "Northeast";
  if (name.includes("South region")) return "South";
  if (name.includes("West region")) return "West";
  return "Unknown";
}

function populateSelect(id, arr){
  const select = document.getElementById(id);
  arr.forEach(item => {
    const option = document.createElement("option");
    option.value = item;
    option.textContent = item;
    select.appendChild(option);
  });
}

// Filter function
function filterData(){
  //Filtering by selected dropdown
  const selectedIndustry = document.getElementById("industry-filter").value;
  const selectedRegion = document.getElementById("region-filter").value;

  filteredData = rawData.filter(d => {
    const industryMatch = selectedIndustry === "all" || getIndustry(d.name) === selectedIndustry;
    const regionMatch = selectedRegion === "all" || getRegion(d.name) === selectedRegion;
    if (selectedRegion !== "all" && selectedRegion !== "US") {
      return d.name.includes("Total nonfarm") && regionMatch;
    } else {
      return industryMatch && getRegion(d.name) === "US";
    }
  });

  // Prepare ratesData and levelsData
  ratesData = filteredData.filter(d => /rate/i.test(d.name)).map(d => ({
    Symbol: d.name.includes("Hires") ? "Hires" : d.name.includes("Job openings") ? "Job openings" : "Total separations",
    Date: d.date,
    Rate: d.value
  }));

  levelsData = filteredData.filter(d => /level/i.test(d.name)).map(d => ({
    Symbol: d.name.includes("Hires") ? "Hires" : d.name.includes("Job openings") ? "Job openings" : "Total separations",
    Date: d.date,
    Rate: d.value
  }));

  drawCharts();
}

// Function: Draw charts, left and right(rates or actual selected?)
function drawCharts(){
  drawLeftChart();
  drawRightChart(currentData === 'rates' ? ratesData : levelsData);
}

//Draw the left chart
function drawLeftChart(){
  d3.select("#chart-left").selectAll("*").remove();

  if (ratesData.length === 0) {
    d3.select("#chart-left").append("text")
      .attr("x", width / 2)
      .attr("y", height / 2)
      .attr("text-anchor", "middle")
      .text("No data available for this selection");
    return;
  }

  // Time scale
  xLeft = d3.scaleUtc()
    .domain(d3.extent(ratesData, d => d.Date))
    .range([marginLeft, width - marginRight]);

  // Normalize each series
  seriesLeft = d3.groups(ratesData, d => d.Symbol).map(([key, values]) => {
    const v0 = values[0].Rate || 1; 
    return {
      key,
      // Store the normalized value
      values: values.map(({Date, Rate}) => ({Date, value: Rate / v0}))
    };
  });

  const k = d3.max(seriesLeft, ({values}) =>
    d3.max(values, d => d.value) / d3.min(values, d => d.value)
  );

  yLeft = d3.scaleLog()
    .domain([1 / k, k])
    .range([height - marginBottom, marginTop]);

  zLeft = d3.scaleOrdinal(d3.schemeCategory10)
    .domain(seriesLeft.map(d => d.key));
  
  // Draw the left chart
  svgLeft = d3.select("#chart-left")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height]);

  // Left chart title
  svgLeft.append("text")
    .attr("x", width / 2)
    .attr("y", 18)
    .attr("text-anchor", "middle")
    .attr("font-size", "20px")
    .attr("font-weight", "bold")
    .text("Normalized Labor Market Metrics Over Time");

  //Tick marks on X-Axis (left-chart)
  svgLeft.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(xLeft).ticks(width / 80).tickSizeOuter(0))
    .call(g => g.select(".domain").remove());

  //From the example code. Create light grey lines for axis
  svgLeft.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(yLeft).ticks(null, x => +x.toFixed(6) + "Ã—")) 
    .call(g => g.selectAll(".tick line").clone()
      .attr("stroke-opacity", d => d === 1 ? null : 0.2)
      .attr("x2", width - marginLeft - marginRight))
    .call(g => g.select(".domain").remove());

  const line = d3.line()
    .x(d => xLeft(d.Date))
    .y(d => yLeft(d.value));

  // Draw each series
  const serieL = svgLeft.append("g")
    .selectAll("g")
    .data(seriesLeft)
    .join("g")
    .attr("class", "series-group-left"); 
  
  serieL.append("path")
    .attr("fill", "none")
    .attr("stroke-width", 1.5)
    .attr("stroke-linejoin", "round")
    .attr("stroke-linecap", "round")
    .attr("stroke", d => zLeft(d.key))
    .attr("d", d => line(d.values));

  //Label for the moving line
  serieL.append("text")
    .datum(d => ({
      key: d.key,
      value: d.values[d.values.length - 1].value
    }))
    .attr("x", xLeft.range()[1] + 3) 
    .attr("y", d => yLeft(d.value)) 
    .attr("dy", "0.35em")
    .attr("fill", d => zLeft(d.key)) 
    .attr("stroke", "white")
    .attr("stroke-width", 3)
    .text(d => d.key);

  // Legend
  const legend = svgLeft.append("g")
    .attr("transform", `translate(${marginLeft+10},${marginTop+10})`);
  seriesLeft.forEach((s,i)=>{
    const g = legend.append("g")
      .attr("transform", `translate(0,${i*20})`);
    g.append("rect").attr("width",12).attr("height",12).attr("fill", zLeft(s.key));
    g.append("text").attr("x",18).attr("y",10).attr("font-size","12px").text(s.key);
  });

  // Vertical mouse line
  ruleLeft = svgLeft.append("line")
    .attr("y1", marginTop)
    .attr("y2", height - marginBottom)
    .attr("stroke", "black")
    .attr("class", "rule-left");

  bisect = d3.bisector(d => d.Date).left; 

  //Animation
  d3.transition()
    .ease(d3.easeCubicOut)
    .duration(1500)
    .tween("date", () => {
      const interp = d3.interpolateDate(xLeft.domain()[1], xLeft.domain()[0]);
      return t => update(interp(t));
    });

  //As the mouse moves, normalize the chart to that date
  svgLeft.on("mousemove touchmove", function(event) {
    const [px] = d3.pointer(event, this);
    update(xLeft.invert(px));
  });
}


// Right chart
function drawRightChart(data){
  d3.select("#chart-right").selectAll("*").remove();
  if(data.length === 0){
    svgRight = d3.select("#chart-right").append("svg")
      .attr("width", width).attr("height", height)
      .append("text")
      .attr("x", width / 2).attr("y", height / 2).attr("text-anchor", "middle")
      .text("No data available");
    return;
  }

  svgRight = d3.select("#chart-right").append("svg").attr("width", width).attr("height", height);

  xRight = d3.scaleUtc().domain(d3.extent(data, d=>d.Date)).range([marginLeft, width - marginRight]);
  yRight = d3.scaleLinear().domain([0, d3.max(data,d=>d.Rate)]).nice().range([height-marginBottom, marginTop]);
  zRight = d3.scaleOrdinal(d3.schemeCategory10).domain(data.map(d=>d.Symbol));

  const lineRight = d3.line().x(d=>xRight(d.Date)).y(d=>yRight(d.Rate));

  const seriesRight = d3.groups(data, d=>d.Symbol).map(([key,values])=>({key, values}));

  // Axes
  svgRight.append("g").attr("transform", `translate(${marginLeft},0)`).call(d3.axisLeft(yRight));
  svgRight.append("g").attr("transform", `translate(0,${height-marginBottom})`).call(d3.axisBottom(xRight).ticks(width/80).tickSizeOuter(0));

  // Lines
  svgRight.append("g").selectAll("path")
    .data(seriesRight).join("path")
    .attr("fill","none")
    .attr("stroke-width",1.5)
    .attr("stroke-linejoin","round")
    .attr("stroke-linecap","round")
    .attr("stroke", d=>zRight(d.key))
    .attr("d", d=>lineRight(d.values));

  // Vertical line
  ruleRight = svgRight.append("line").attr("y1", marginTop).attr("y2", height-marginBottom).attr("stroke","black");
}

// Dataset toggle
function updateDataset(type){
  currentData = type;
  document.getElementById('button_rates').classList.toggle('active', type==='rates');
  document.getElementById('button_actual').classList.toggle('active', type==='actual');
  drawRightChart(type==='rates'?ratesData:levelsData);
}

function update(date) {
  // Error check
  if (!xLeft || !bisect) return; 

  date = d3.utcDay.round(date);
//update rules for left and right
  ruleLeft.attr("transform", `translate(${xLeft(date)},0)`);

  if (ruleRight) {
    ruleRight.attr("transform", `translate(${xRight(date)},0)`); 
  }

  d3.select("#chart-left").selectAll(".series-group-left")
    .attr("transform", ({key, values}) => {
      const i = bisect(values, date, 0, values.length - 1);
      const v_date = values[i].value; 
    
      const shift = yLeft(1) - yLeft(v_date);
      
      return `translate(0,${shift})`;
    });
}

</script>

</body>
</html>
