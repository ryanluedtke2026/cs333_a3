<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 Labor Market Metrics</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
    }
    #chart-left, #chart-right {
      display: inline-block;
      vertical-align: top;
      margin: 0 10px;
    }

    button {
      padding: 8px 16px;
      margin: 0 5px;
      font-size: 14px;
      cursor: pointer;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button.active {
      background-color: black;
      color: white;
    }
    select {
      padding: 8px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
</head>

<body>

<h1 style="text-align: center; margin: 20px 0;">Labor Market Metrics</h1>

<div style="text-align: center; margin-bottom: 20px;">
  <label for="industry-filter">Industry: </label>
  <select id="industry-filter"></select>
  
  <label for="region-filter" style="margin-left: 20px;">Region: </label>
  <select id="region-filter"></select>
</div>

<div style="display: flex; justify-content: center;">
  <div id="chart-left"></div>
  <div id="chart-right-container" style="position: relative;">
    <div style="text-align: center; margin-bottom: 10px;">
      <button id="button_rates" onclick="updateDataset('rates')">Rates</button>
      <button id="button_actual" onclick="updateDataset('actual')">Actual</button>
    </div>
    <div id="chart-right"></div>
  </div>
</div>

<script>

// Global variables for charts
const width = 700;
const height = 460;
const marginTop = 20;
const marginRight = 40;
const marginBottom = 30;
const marginLeft = 40;

let rawData, filteredData;
let ratesData = [], levelsData = [];
let currentData = 'rates';
let svgLeft, svgRight, xLeft, yLeft, zLeft, seriesLeft;
let ruleLeft, ruleRight;

// load CSV
d3.csv("clean_bls_long_format_2.csv", d => ({
  name: d.name.trim(),
  date: new Date(d.date),
  value: +d.value
})).then(raw => {
  //filter data so that date is always valid
  rawData = raw.filter(d => 
    d.value > 0 &&              
    d.date instanceof Date &&
    !isNaN(d.date.getTime())
  );

  //industry and region dropdown categories
  const industryCat = ["Total nonfarm", 
    "Total private",
    "Trade, transportation, and utilities",
    "Construction", 
    "Financial activities", 
    "Information",
    "Leisure and hospitality",
    "Manufacturing",
    "Mining and logging",
    "Private education and health services",
    "Professional and business services",
    "Other services",
    "Government",
    "State and local",
    "Federal"
  ];

  const regionCat = ["US", "Midwest", "Northeast", "South", "West"];

  // Populate industry and region dropdown
  populateSelect("industry-filter", industryCat);
  populateSelect("region-filter", regionCat);

  // Initial selection
  document.getElementById("industry-filter").value = "Total nonfarm";
  document.getElementById("region-filter").value = "US";

  // Event listeners -- for interaction on the buttons
  document.getElementById("industry-filter").addEventListener("change", () => {
    if (document.getElementById("industry-filter").value !== "all") 
      document.getElementById("region-filter").value = "US";
    filterData();
  });

  document.getElementById("region-filter").addEventListener("change", () => {
    const region = document.getElementById("region-filter").value;
    if (region !== "all" && region !== "US") 
      document.getElementById("industry-filter").value = "Total nonfarm";
    filterData();
  });

  // Initial filter and chart
  filterData();
  document.getElementById('button_rates').classList.add('active');
});

// Get industry and get region functions
function getIndustry(name){
  const match = name.match(/^(.+?) Total US/);
  return match ? match[1].trim() : name;
}

function getRegion(name){
  if (name.includes("Total US")) return "US";
  if (name.includes("Midwest region")) return "Midwest";
  if (name.includes("Northeast region")) return "Northeast";
  if (name.includes("South region")) return "South";
  if (name.includes("West region")) return "West";
  return "Unknown";
}

function populateSelect(id, arr){
  const select = document.getElementById(id);
  arr.forEach(item => {
    const option = document.createElement("option");
    option.value = item;
    option.textContent = item;
    select.appendChild(option);
  });
}

// Filter function
function filterData(){
  //Filtering by selected dropdown
  const selectedIndustry = document.getElementById("industry-filter").value;
  const selectedRegion = document.getElementById("region-filter").value;

  filteredData = rawData.filter(d => {
    const industryMatch = selectedIndustry === "all" || getIndustry(d.name) === selectedIndustry;
    const regionMatch = selectedRegion === "all" || getRegion(d.name) === selectedRegion;
    if (selectedRegion !== "all" && selectedRegion !== "US") {
      return d.name.includes("Total nonfarm") && regionMatch;
    } else {
      return industryMatch && getRegion(d.name) === "US";
    }
  });

  // Prepare ratesData and levelsData
  ratesData = filteredData.filter(d => /rate/i.test(d.name)).map(d => ({
    Symbol: d.name.includes("Hires") ? "Hires" : d.name.includes("Job openings") ? "Job openings" : "Total separations",
    Date: d.date,
    Rate: d.value
  }));

  levelsData = filteredData.filter(d => /level/i.test(d.name)).map(d => ({
    Symbol: d.name.includes("Hires") ? "Hires" : d.name.includes("Job openings") ? "Job openings" : "Total separations",
    Date: d.date,
    Rate: d.value
  }));

  // Draw charts
  drawCharts();
}

// Draw charts
function drawCharts(){
  drawLeftChart();
  drawRightChart(currentData === 'rates' ? ratesData : levelsData);
}

//Draw the left chart
function drawLeftChart(){
  d3.select("#chart-left").selectAll("*").remove();

  if (ratesData.length === 0) {
    d3.select("#chart-left").append("text")
      .attr("x", width / 2)
      .attr("y", height / 2)
      .attr("text-anchor", "middle")
      .text("No data available for this selection");
    return;
  }

  // Draw the left chart
  svgLeft = d3.select("#chart-left")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  // Time scale
  xLeft = d3.scaleUtc()
    .domain(d3.extent(ratesData, d => d.Date))
    .range([marginLeft, width - marginRight]);

  // Normalize each series
  seriesLeft = d3.groups(ratesData, d => d.Symbol).map(([key, values]) => {
    const v0 = values[0].Rate || 1;  // safeguard against 0
    return {
      key,
      values: values.map(({Date, Rate}) => ({Date, value: Rate / v0}))
    };
  });

  const k = d3.max(seriesLeft, ({values}) =>
    d3.max(values, d => d.value) / d3.min(values, d => d.value)
  );

  yLeft = d3.scaleLog()
    .domain([1 / k, k])
    .range([height - marginBottom, marginTop]);

  zLeft = d3.scaleOrdinal(d3.schemeCategory10)
    .domain(seriesLeft.map(d => d.key));

  // Left chart title
  svgLeft.append("text")
    .attr("x", width / 2)
    .attr("y", 18)
    .attr("text-anchor", "middle")
    .attr("font-size", "20px")
    .attr("font-weight", "bold")
    .text("Normalized Labor Market Metrics Over Time");

  // X-Axis
  svgLeft.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(xLeft).ticks(width / 80).tickSizeOuter(0))
    .call(g => g.select(".domain").remove());

  // Y-Axis
  svgLeft.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(yLeft))
    .call(g => g.selectAll(".tick line").clone()
      .attr("stroke-opacity", 0.2)
      .attr("x2", width - marginLeft - marginRight))
    .call(g => g.select(".domain").remove());

  const line = d3.line()
    .x(d => xLeft(d.Date))
    .y(d => yLeft(d.value));

  // Draw each series
  const serieG = svgLeft.append("g")
    .selectAll("g")
    .data(seriesLeft)
    .join("g");

  serieG.append("path")
    .attr("fill", "none")
    .attr("stroke-width", 1.5)
    .attr("stroke-linejoin", "round")
    .attr("stroke-linecap", "round")
    .attr("stroke", d => zLeft(d.key))
    .attr("d", d => line(d.values));

  // Legend
  const legend = svgLeft.append("g")
    .attr("transform", `translate(${marginLeft+10},${marginTop+10})`);
  seriesLeft.forEach((s,i)=>{
    const g = legend.append("g")
      .attr("transform", `translate(0,${i*20})`);
    g.append("rect").attr("width",12).attr("height",12).attr("fill", zLeft(s.key));
    g.append("text").attr("x",18).attr("y",10).attr("font-size","12px").text(s.key);
  });

  // Vertical mouse line
  ruleLeft = svgLeft.append("line")
    .attr("y1", marginTop)
    .attr("y2", height - marginBottom)
    .attr("stroke", "black");

  // Mouse interaction to show normalized line
  svgLeft.on("mousemove touchmove", function(event){
    const [px] = d3.pointer(event, this);
    const date = xLeft.invert(px);

    ruleLeft.attr("x1", xLeft(date)).attr("x2", xLeft(date));

    // Move each line's last label vertically (optional)
    serieG.selectAll("text")
      .data(seriesLeft)
      .join("text")
      .attr("x", xLeft.range()[1] + 3)
      .attr("y", d => {
        const bisect = d3.bisector(d => d.Date).left;
        const i = bisect(d.values, date, 0, d.values.length - 1);
        return yLeft(d.values[i].value);
      })
      .text(d => d.key)
      .attr("fill", d => zLeft(d.key))
      .attr("stroke", "white")
      .attr("stroke-width", 3)
      .attr("dy", "0.35em");
  });
}


// Right chart
function drawRightChart(data){
  d3.select("#chart-right").selectAll("*").remove();
  if(data.length === 0){
    svgRight = d3.select("#chart-right").append("svg")
      .attr("width", width).attr("height", height)
      .append("text")
      .attr("x", width / 2).attr("y", height / 2).attr("text-anchor", "middle")
      .text("No data available");
    return;
  }

  svgRight = d3.select("#chart-right").append("svg").attr("width", width).attr("height", height);

  xRight = d3.scaleUtc().domain(d3.extent(data, d=>d.Date)).range([marginLeft, width - marginRight]);
  yRight = d3.scaleLinear().domain([0, d3.max(data,d=>d.Rate)]).nice().range([height-marginBottom, marginTop]);
  zRight = d3.scaleOrdinal(d3.schemeCategory10).domain(data.map(d=>d.Symbol));

  const lineRight = d3.line().x(d=>xRight(d.Date)).y(d=>yRight(d.Rate));

  const seriesRight = d3.groups(data, d=>d.Symbol).map(([key,values])=>({key, values}));

  // Axes
  svgRight.append("g").attr("transform", `translate(${marginLeft},0)`).call(d3.axisLeft(yRight));
  svgRight.append("g").attr("transform", `translate(0,${height-marginBottom})`).call(d3.axisBottom(xRight).ticks(width/80).tickSizeOuter(0));

  // Lines
  svgRight.append("g").selectAll("path")
    .data(seriesRight).join("path")
    .attr("fill","none")
    .attr("stroke-width",1.5)
    .attr("stroke-linejoin","round")
    .attr("stroke-linecap","round")
    .attr("stroke", d=>zRight(d.key))
    .attr("d", d=>lineRight(d.values));

  // Vertical line
  ruleRight = svgRight.append("line").attr("y1", marginTop).attr("y2", height-marginBottom).attr("stroke","black");
}

// Dataset toggle
function updateDataset(type){
  currentData = type;
  document.getElementById('button_rates').classList.toggle('active', type==='rates');
  document.getElementById('button_actual').classList.toggle('active', type==='actual');
  drawRightChart(type==='rates'?ratesData:levelsData);
}

</script>

</body>
</html>
